// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ap preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`ap preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`ap updates result when inputs update 1`] = `
Array [
  "after 10 ms...",
  11,
  "after 2 ms...",
  9,
  "after 8 ms...",
  4,
]
`;

exports[`chain preserves disposer of main sream 1`] = `
Array [
  Array [],
]
`;

exports[`chain preserves disposer of spawned streams 1`] = `
Array [
  Array [],
]
`;

exports[`chain result stream contains values from spawned at correct time 1`] = `
Array [
  "after 11 ms...",
  2,
  "after 1 ms...",
  3,
  "after 9 ms...",
  4,
  "after 1 ms...",
  6,
]
`;

exports[`chainLatest doesn't contain values emited from old spawned streams 1`] = `
Array [
  "after 16 ms...",
  2,
  "after 10 ms...",
  4,
  "after 6 ms...",
  6,
]
`;

exports[`chainLatest preserves disposer of main sream 1`] = `
Array [
  Array [],
]
`;

exports[`chainLatest preserves disposer of spawned streams 1`] = `
Array [
  Array [],
]
`;

exports[`chainLatest result stream contains values from spawned at correct time 1`] = `
Array [
  "after 11 ms...",
  2,
  "after 1 ms...",
  3,
  "after 9 ms...",
  4,
  "after 1 ms...",
  6,
]
`;

exports[`combineArray preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`combineArray preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`combineArray preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`combineArray result stream contains values from sources 1`] = `
Array [
  "after 10 ms...",
  Array [
    1,
    3,
    5,
    7,
  ],
  "after 2 ms...",
  Array [
    1,
    4,
    5,
    7,
  ],
  "after 2 ms...",
  Array [
    2,
    4,
    5,
    7,
  ],
  "after 6 ms...",
  Array [
    2,
    4,
    6,
    7,
  ],
]
`;

exports[`combineArray works with one stream 1`] = `
Array [
  "after 7 ms...",
  Array [
    1,
  ],
  "after 7 ms...",
  Array [
    2,
  ],
]
`;

exports[`combineArray works with zero streams 1`] = `
Array [
  Array [],
]
`;

exports[`empty subscriber is never called 1`] = `Array []`;

exports[`filter preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`filter removes values 1`] = `
Array [
  "after 20 ms...",
  2,
]
`;

exports[`fromIterable works with array 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    3,
  ],
]
`;

exports[`fromIterable works with generator 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    3,
  ],
]
`;

exports[`fromLoose callback is called 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
]
`;

exports[`fromLoose disposer is called 1`] = `
Array [
  Array [],
]
`;

exports[`fromLoose fixes stream #4: \`cb\` must be called with one argument 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`fromLoose fixes stream #6: After \`disposer\` was called, \`cb\` must not be called 1`] = `Array []`;

exports[`fromLoose fixes usage #1: \`stream\` must be called with one argument, \`cb\` 1`] = `
Array [
  Array [
    [Function],
  ],
]
`;

exports[`fromLoose fixes usage #4: \`disposer\` must be called with no arguments 1`] = `
Array [
  Array [],
]
`;

exports[`fromLoose fixes usage #5: \`disposer\` must be called at most once 1`] = `
Array [
  Array [],
]
`;

exports[`map modifies values with provided fn 1`] = `
Array [
  "after 10 ms...",
  2,
  "after 10 ms...",
  3,
]
`;

exports[`map preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`map2 preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`map2 preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`map2 updates result when inputs update 1`] = `
Array [
  "after 10 ms...",
  Array [
    1,
    3,
  ],
  "after 2 ms...",
  Array [
    2,
    3,
  ],
  "after 8 ms...",
  Array [
    2,
    4,
  ],
]
`;

exports[`map3 preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`map3 preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`map3 preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`map3 updates result when inputs update 1`] = `
Array [
  "after 10 ms...",
  Array [
    1,
    3,
    5,
  ],
  "after 2 ms...",
  Array [
    1,
    4,
    5,
  ],
  "after 2 ms...",
  Array [
    2,
    4,
    5,
  ],
  "after 6 ms...",
  Array [
    2,
    4,
    6,
  ],
]
`;

exports[`merge preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`merge preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`merge preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`merge result stream contains values from sources 1`] = `
Array [
  "after 6 ms...",
  3,
  "after 1 ms...",
  1,
  "after 3 ms...",
  5,
  "after 2 ms...",
  4,
  "after 2 ms...",
  2,
  "after 6 ms...",
  6,
]
`;

exports[`multicast first and second sunscribers get same async events 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast first and second sunscribers get same async events 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast first subscribers gets sync events 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast preserves disposer (single subscriber) 1`] = `
Array [
  Array [],
]
`;

exports[`multicast preserves disposer (two subscribers) 1`] = `
Array [
  Array [],
]
`;

exports[`multicast second subscribers doesn't get sync events 1`] = `Array []`;

exports[`multicast subscriber doesn't get event after unsub() in response to that event 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`multicast unsub doesn't remove another version of same subscriber 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`of calls callback with the value 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`scan contains correct values 1`] = `
Array [
  Array [],
  "after 10 ms...",
  Array [
    1,
  ],
  "after 10 ms...",
  Array [
    1,
    2,
  ],
]
`;

exports[`scan preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skip preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skip returns equivalent stream if N is 0 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
  "after 10 ms...",
  3,
]
`;

exports[`skip skips first N items 1`] = `
Array [
  "after 30 ms...",
  3,
]
`;

exports[`skipDuplicates doesn't apply comparator to the first element 1`] = `Array []`;

exports[`skipDuplicates preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skipDuplicates removes duplicates 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 20 ms...",
  3,
]
`;

exports[`skipWhile preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skipWhile returns empty stream if predicate is () => true 1`] = `Array []`;

exports[`skipWhile returns equivalent stream if predicate is () => false 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
  "after 10 ms...",
  3,
]
`;

exports[`skipWhile skips first items that satisfy predicate 1`] = `
Array [
  "after 30 ms...",
  3,
]
`;

exports[`startWith adds a value 1`] = `
Array [
  0,
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
]
`;

exports[`startWith preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`take calls disposer of source stream when we dispose result stream 1`] = `
Array [
  Array [],
]
`;

exports[`take contains correct values at correct time 1`] = `
Array [
  "after 10 ms...",
  1,
]
`;

exports[`take doesn't call disposer twice 1`] = `
Array [
  Array [],
]
`;

exports[`take if n is 0 returns empty stream 1`] = `Array []`;

exports[`take subscribes to source even if n is 0 1`] = `
Array [
  Array [
    [Function],
  ],
]
`;

exports[`take takes first n and then calls disposer of source stream (async) 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`take takes first n and then calls disposer of source stream (sync) 1`] = `
Array [
  Array [],
]
`;

exports[`take takes first n and then calls disposer of source stream (sync) 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`takeUntil calls disposers after first value in controller 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers after first value in controller 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers properly (async value in controller) 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers properly (async value in controller) 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers when we dispose result stream erlier 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers when we dispose result stream erlier 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil doesn't contain values after sync value from controller 1`] = `Array []`;

exports[`takeUntil doesn't contain values after value from controller 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
]
`;

exports[`takeUntil subscribes first to source and then to controller 1`] = `
Array [
  1,
  2,
]
`;

exports[`takeWhile calls disposer of source stream when we dispose result stream erlier 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile contains correct values at correct time 1`] = `
Array [
  "after 10 ms...",
  1,
  "after 10 ms...",
  2,
]
`;

exports[`takeWhile doesn't call disposer twice 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile return empty stream if predicate is () => false 1`] = `Array []`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (async) 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (sync) 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (sync) 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;
