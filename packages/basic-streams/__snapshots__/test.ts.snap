// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ap preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`ap preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`ap updates result when inputs update 1`] = `
EventsList(
  10: 11
  12: 9
  20: 4
)
`;

exports[`chain preserves disposer of main sream 1`] = `
Array [
  Array [],
]
`;

exports[`chain preserves disposer of spawned streams 1`] = `
Array [
  Array [],
]
`;

exports[`chain result stream contains values from spawned at correct time 1`] = `
EventsList(
  11: 2
  12: 3
  21: 4
  22: 6
)
`;

exports[`chainLatest doesn't contain values emited from old spawned streams 1`] = `
EventsList(
  16: 2
  26: 4
  32: 6
)
`;

exports[`chainLatest preserves disposer of main sream 1`] = `
Array [
  Array [],
]
`;

exports[`chainLatest preserves disposer of spawned streams 1`] = `
Array [
  Array [],
]
`;

exports[`chainLatest result stream contains values from spawned at correct time 1`] = `
EventsList(
  11: 2
  12: 3
  21: 4
  22: 6
)
`;

exports[`combineArray preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`combineArray preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`combineArray preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`combineArray result stream contains values from sources 1`] = `
EventsList(
  10: Array [
    1,
    3,
    5,
    7,
  ]
  12: Array [
    1,
    4,
    5,
    7,
  ]
  14: Array [
    2,
    4,
    5,
    7,
  ]
  20: Array [
    2,
    4,
    6,
    7,
  ]
)
`;

exports[`combineArray works with one stream 1`] = `
EventsList(
  7: Array [
    1,
  ]
  14: Array [
    2,
  ]
)
`;

exports[`combineArray works with zero streams 1`] = `
EventsList(
  0: Array []
)
`;

exports[`empty subscriber is never called 1`] = `Array []`;

exports[`filter preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`filter removes values 1`] = `
EventsList(
  20: 2
)
`;

exports[`fromIterable works with array 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    3,
  ],
]
`;

exports[`fromIterable works with generator 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    3,
  ],
]
`;

exports[`fromLoose callback is called 1`] = `
EventsList(
  10: 1
  20: 2
)
`;

exports[`fromLoose disposer is called 1`] = `
Array [
  Array [],
]
`;

exports[`fromLoose fixes stream #4: \`cb\` must be called with one argument 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`fromLoose fixes stream #6: After \`disposer\` was called, \`cb\` must not be called 1`] = `Array []`;

exports[`fromLoose fixes usage #1: \`stream\` must be called with one argument, \`cb\` 1`] = `
Array [
  Array [
    [Function],
  ],
]
`;

exports[`fromLoose fixes usage #4: \`disposer\` must be called with no arguments 1`] = `
Array [
  Array [],
]
`;

exports[`fromLoose fixes usage #5: \`disposer\` must be called at most once 1`] = `
Array [
  Array [],
]
`;

exports[`map modifies values with provided fn 1`] = `
EventsList(
  10: 2
  20: 3
)
`;

exports[`map preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`map2 preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`map2 preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`map2 updates result when inputs update 1`] = `
EventsList(
  10: Array [
    1,
    3,
  ]
  12: Array [
    2,
    3,
  ]
  20: Array [
    2,
    4,
  ]
)
`;

exports[`map3 preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`map3 preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`map3 preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`map3 updates result when inputs update 1`] = `
EventsList(
  10: Array [
    1,
    3,
    5,
  ]
  12: Array [
    1,
    4,
    5,
  ]
  14: Array [
    2,
    4,
    5,
  ]
  20: Array [
    2,
    4,
    6,
  ]
)
`;

exports[`merge preserves disposers 1`] = `
Array [
  Array [],
]
`;

exports[`merge preserves disposers 2`] = `
Array [
  Array [],
]
`;

exports[`merge preserves disposers 3`] = `
Array [
  Array [],
]
`;

exports[`merge result stream contains values from sources 1`] = `
EventsList(
  6: 3
  7: 1
  10: 5
  12: 4
  14: 2
  20: 6
)
`;

exports[`multicast first and second sunscribers get same async events 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast first and second sunscribers get same async events 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast first subscribers gets sync events 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`multicast preserves disposer (single subscriber) 1`] = `
Array [
  Array [],
]
`;

exports[`multicast preserves disposer (two subscribers) 1`] = `
Array [
  Array [],
]
`;

exports[`multicast second subscribers doesn't get sync events 1`] = `Array []`;

exports[`multicast subscriber doesn't get event after unsub() in response to that event 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`multicast unsub doesn't remove another version of same subscriber 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`of calls callback with the value 1`] = `
Array [
  Array [
    1,
  ],
]
`;

exports[`scan contains correct values 1`] = `
EventsList(
  0: Array []
  10: Array [
    1,
  ]
  20: Array [
    1,
    2,
  ]
)
`;

exports[`scan preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skip preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skip returns equivalent stream if N is 0 1`] = `
EventsList(
  10: 1
  20: 2
  30: 3
)
`;

exports[`skip skips first N items 1`] = `
EventsList(
  30: 3
)
`;

exports[`skipDuplicates doesn't apply comparator to the first element 1`] = `Array []`;

exports[`skipDuplicates preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skipDuplicates removes duplicates 1`] = `
EventsList(
  10: 1
  30: 3
)
`;

exports[`skipWhile preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`skipWhile returns empty stream if predicate is () => true 1`] = `EventsList()`;

exports[`skipWhile returns equivalent stream if predicate is () => false 1`] = `
EventsList(
  10: 1
  20: 2
  30: 3
)
`;

exports[`skipWhile skips first items that satisfy predicate 1`] = `
EventsList(
  30: 3
)
`;

exports[`startWith adds a value 1`] = `
EventsList(
  0: 0
  10: 1
  20: 2
)
`;

exports[`startWith preserves disposer 1`] = `
Array [
  Array [],
]
`;

exports[`take calls disposer of source stream when we dispose result stream 1`] = `
Array [
  Array [],
]
`;

exports[`take contains correct values at correct time 1`] = `
EventsList(
  10: 1
)
`;

exports[`take doesn't call disposer twice 1`] = `
Array [
  Array [],
]
`;

exports[`take if n is 0 returns empty stream 1`] = `EventsList()`;

exports[`take subscribes to source even if n is 0 1`] = `
Array [
  Array [
    [Function],
  ],
]
`;

exports[`take takes first n and then calls disposer of source stream (async) 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`take takes first n and then calls disposer of source stream (sync) 1`] = `
Array [
  Array [],
]
`;

exports[`take takes first n and then calls disposer of source stream (sync) 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`takeUntil calls disposers after first value in controller 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers after first value in controller 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers properly (async value in controller) 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers properly (async value in controller) 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers when we dispose result stream erlier 1`] = `
Array [
  Array [],
]
`;

exports[`takeUntil calls disposers when we dispose result stream erlier 2`] = `
Array [
  Array [],
]
`;

exports[`takeUntil doesn't contain values after sync value from controller 1`] = `EventsList()`;

exports[`takeUntil doesn't contain values after value from controller 1`] = `
EventsList(
  10: 1
  20: 2
)
`;

exports[`takeUntil subscribes first to controller and then to source 1`] = `Array []`;

exports[`takeWhile calls disposer of source stream when we dispose result stream erlier 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile contains correct values at correct time 1`] = `
EventsList(
  10: 1
  20: 2
)
`;

exports[`takeWhile doesn't call disposer twice 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile return empty stream if predicate is () => false 1`] = `EventsList()`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (async) 1`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (sync) 1`] = `
Array [
  Array [],
]
`;

exports[`takeWhile takes values that satisfy predicate until first value that don't then calls disposer (sync) 2`] = `
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
]
`;
